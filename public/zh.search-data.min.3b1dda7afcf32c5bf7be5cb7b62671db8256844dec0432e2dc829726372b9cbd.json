[{"id":0,"href":"/posts/sequence/","title":"数列","section":"notes","content":"定义 #  有序元素集，整数子集到另一个集合的映射\n例: \\( \\{a_{n}\\} \\)， \\(a_n = \\frac {1}{n}\\)，\\(n \\in \\mathbb{Z^+} \\)\n等比级数 #  \\(a, ar, ar^2,\u0026hellip;,ar^n\\), (\\(a,r \\in R\\))，r 为公比\n等差数列 #  \\(a, a+d, a+2d, \u0026hellip; ,a+nd, \u0026hellip;\\), d 为公差\nFibonacci sequence #  斐波那契数列\n\\(f_0 = 0, f_1 = 1, f_n = f_{n-1} + f_{n-2}, ( n \\geq 2, n \\in \\mathbb{Z^+} ) \\)\n"},{"id":1,"href":"/posts/priority-queue/","title":"优先队列","section":"notes","content":"定义 #  "},{"id":2,"href":"/posts/heap/","title":"堆","section":"notes","content":"定义 #  可以用完整二叉树表示的数组，树的每一个节点为数组中的元素\nparent(i) = Math.floor(i/2)\nleft(i) = 2i\nright(i) = 2i + 1\nMax heap #  最大堆\n除了根节点 A[i] \u0026lt;= A[parent(i)]\nMin heap #  最小堆\n除了根节点，A[i] \u0026gt;= A[parent(i)]\n通常用来实现优先队列\n"},{"id":3,"href":"/posts/quick-sort/","title":"快速排序","section":"notes","content":"实现 #   /** *数组分割 * */ const partition = (arr, p, r) =\u0026gt; {  // 去数组最后一个元素为分割点  const pivot = arr[r];  let i = p - 1;   // 遍历，将比分割点小的元素都挪到左边  for (let j = p; j \u0026lt; r; j++) {  if (arr[j] \u0026lt;= pivot) {  i++;  let tmp = arr[i];  arr[i] = arr[j];  arr[j] = tmp;  }  }  // 将分割点的元素挪到左右数组中间  const tmp = arr[i + 1];  arr[i + 1] = pivot;  arr[r] = tmp;   // 返回分割点的索引  return i + 1; };  /** * 快速排序 */ const quickSort = (arr, p, r) =\u0026gt; {  // p \u0026lt; r 时，数组中不止一个元素，需要排序，否则无需排序  if (p \u0026lt; r) {  // 数组分割，找出分割点索引，分割点左侧的值都不大于分割点，右侧的值都大于分割点  const pivotIdx = partition(arr, p, r);  console.log(\u0026#34;pivotidx\u0026#34;, pivotIdx);  // 快排左右两侧的子数组，注意这俩子数组里均不包含 pivotIdx  // 左数组快排  quickSort(arr, p, pivotIdx - 1);  // 右数组快排  quickSort(arr, pivotIdx + 1, r);  }   return arr; };  const arr = [2, 8, 7, 1, 3, 5, 6, 4];  console.log(\u0026#34;quick\u0026#34;, quickSort(arr, 0, arr.length - 1));  export { quickSort }; 分析 #  复杂度：\n"},{"id":4,"href":"/posts/set/","title":"集合","section":"notes","content":"定义 #  不同 对象的 无序 集合\n表示 #  Roster method #  花名册法，枚举集合里的每个元素\nSet builder notation #  集合构造器表示法\n例如： \\( O = \\{x \\mid x 为奇数 \\} \\) 或 \\( O = \\{x: x 为奇数 \\} \\)\n"},{"id":5,"href":"/posts/insert-sort/","title":"插入排序","section":"notes","content":"实现 #  时间复杂度 \\( O(n^2 \\)\n const insertSort = (arr) =\u0026gt; {  const len = arr.length   // 从第二个元素开始遍历  for (let i = 1; i \u0026lt; len; i ++ ) {   const ele = arr[i]   // 索引i位置的值依次跟前面的元素比  for (let j = i - 1; j \u0026gt;= 0; j --) {   const cur = arr[j]  const next = arr[j + 1]   if(cur \u0026lt; ele) {  break  }   arr[j] = next  arr[j+1] = cur  }   }   return arr } 分析 #  "},{"id":6,"href":"/posts/header-files/","title":"头文件","section":"notes","content":"头文件 #  用于将函数，变量声明放在同一个文件里，便于被其他文件引用\n仅包含声明，不包含定义，定义在 linker 阶段链接到程序里\n如下图\n  #include \u0026#34;something.h\u0026#34; /*当前目录下找*/ #include \u0026lt;iostream\u0026gt; /*在系统环境里找, include directory*/"},{"id":7,"href":"/posts/c-preprocessor/","title":"C 预处理器","section":"notes","content":"预处理 #  C: C 或 C++\n程序编译前的转换过程，不修改源文件，仅在内存中完成转换\npreprocessor 不理解 C 的语法\n指令在编译前被解析\n 参考\n预处理指令 #  以 #symbol 开头（symbol为指令字符），以换行符结尾;\n常用指令\n   指令 含义     #include 引入头文件   #define 宏定义   #ifdef, #ifndef, #endif. 条件编译指令   #if 0 不编译某些代码块    Object-like Macros #  类对象宏\n#define PRINT_JOE /* 用于条件编译 */#define MY_NAME \u0026#34;Alex\u0026#34; /* 用于常量定义, 老代码里用到 */"},{"id":8,"href":"/posts/probability/","title":"离散概率","section":"notes","content":"概率 #  抽样实验 #  从可能的结果集里取值的过程\n取样空间 #  可能的结果集\n抽样事件 #  取样空间的子集\n定义 #  如果 \\( S \\) 为有限的非空的等概率的取样空间，\\(E\\) 为抽样事件，那么 \\(E\\) 的概率为 \\(p(E) = \\frac{\\vert E \\vert}{\\vert S \\vert}\\)\n定理 #  抽样事件 \\(E\\) 的补集 \\(\\bar E\\) 的概率为 \\(p(\\bar E)= 1 - p(E)\\)\n"},{"id":9,"href":"/posts/counting/","title":"计数问题","section":"notes","content":"计数法则 #  积法则 #  假定任务 Task 可以分两步去解决，第一步有 \\(n_1\\) 种解决方法，第二步有 \\(n_2\\) 种解决方法，那么解决任务 Task 总共有 \\(n_1 \\times n_2\\) 种方法\n和法则 #  如果任务 Task 在条件一下有 \\(n_1\\) 种方法解决，在条件二下有 \\(n_2\\) 种方法解决，那么在两种条件都考虑的情况下，任务 Task 共有 \\(n_1 + n_2\\) 种解决方法\nPermutations and Combinations #  排列组合\n排列 #  有序\nn 元集里的 r 排列：\n\\[ n, r \\in \\mathbb{Z^{+}}, 1 \\leq r \\leq n ，P(n,r)=n(n-1)(n-2)\u0026hellip;(n-r+1)= \\frac{n!}{(n-r)!} \\]\n组合 #  无序\nn 元集里的 r 组合，表示为 \\(C(n,r)\\)，或 \\(\\binom n r\\)\n\\[C(n,r) = \\frac{P(n,r)}{P(r,r)}=\\frac{n!}{r!(n-r)!}\\]\n\\[C(n,r)=C(n, n-r)\\]\n"},{"id":10,"href":"/posts/bnf/","title":"编程语言语法","section":"notes","content":"BNF #  Backus-Naur form (BNF)，用于描述计算机编程语言的语法规则\n"},{"id":11,"href":"/posts/expo-and-loga/","title":"指数和对数","section":"notes","content":"指数 #  定义： \\( b \\in \\mathbb{R^+}, n \\in \\mathbb{R^+} \\), \\(f_b(n) = b^n = b \\cdot b \\cdot b \\cdot \u0026hellip; \\cdot b\\)，n 个 b 相乘\n定理：\n \\(b^{x+y} = b^x \\cdot b^y\\) \\((b^x)^y=b^{x \\cdot y}\\)  对数 #  定义： \\(f = \\log_b x \\)，以 b 为底的 x 的对数值\n\\(b^x = a, x = \\log_b a\\)\n\\(b^{\\log_b a} = a\\)\n定理：\n \\(\\log_b (x \\cdot y)=\\log_b x + \\log_b y\\) \\(\\log_b (x^y)=y \\cdot \\log_b x\\) \\(\\log_a x = \\frac{\\log_b x}{\\log_b a}=\\frac{1}{ \\log_b a} \\cdot \\log_b x\\)，（换底，常量值乘以 b 为底的对数）  在计算机领域，\\(\\log x\\)，底省略时，通常指以 2 为底的对数\n"},{"id":12,"href":"/posts/mysql/","title":"Mysql","section":"notes","content":"KEY, INDEX #  KEY, INDEX，是同义词，避免全表扫描，提高数据检索速度\nPRIMARY, UNIQUE #  用来确保数据的唯一性（插入或更新时），即不能有两行一样的数据（某一列或几列一致），即列或组合列的值要唯一\nprimary key: 主键，一个表最多只有一个主键，是唯一索引的特殊形式，用于唯一标识表里的某一行数据，只能用在非空列上\nunique index: 唯一索引， 可以有多个唯一索引, 可以用在空(NULL)列上\n"},{"id":13,"href":"/posts/merge-sort/","title":"归并排序","section":"notes","content":"实现 #  归并排序，采用分治法，时间复杂度为 \\(O(nlog n)\\)\n /** * @param {number[]} arr 待合并原始数组 * @param {number} p 左索引，第一个元素的索引 * @param {number} q 中位索引 * @param {number} r 右索引，最后一个元素的索引 * * [p, q), [q, r] 均为已排序好的子数组 * * 将 [p,q), [q, r] 合并为一个排序好的数组 * */ const merge = (arr, p, q, r) =\u0026gt; {  // concat 的为哨兵节点  const arrLeft = arr.slice(p, q + 1).concat(Number.POSITIVE_INFINITY);  const arrRight = arr.slice(q + 1, r + 1).concat(Number.POSITIVE_INFINITY);   let indexL = 0;  let indexR = 0;   // 注意，遍历从 p 开始，到 r+1  for (let i = p; i \u0026lt; r + 1; i++) {  if (arrLeft[indexL] \u0026lt; arrRight[indexR]) {  arr[i] = arrLeft[indexL];  indexL++;  } else {  arr[i] = arrRight[indexR];  indexR++;  }  } };  /** * 归并排序 * @param {number[]} arr 待排序数组 * @param {number} p 左索引 第一个元素的索引 * @param {number} r 右索引 最后一个元素的索引 * * 思路: 将大数组按中位索引依次拆为更小的两个子数组，将两个子数组排序，然后合并两个排序好的子数组 * * 注意：当拆到最后子数组只有一个元素时，默认为已排序好的，此为递归的终止条件 */ const mergeSort = (arr, p, r) =\u0026gt; {  if (p \u0026lt; r) {  let median = Math.floor((p + r) / 2);  // 排序左数组  mergeSort(arr, p, median);   // 排序右数组  mergeSort(arr, median + 1, r);   // 合并两个排序好的子数组  merge(arr, p, median, r);  // console.log(\u0026#34;arr\u0026#34;, arr);  }  return arr; };  export { mergeSort };  const arr = [5, 2, 4, 7, 1, 3, 2]; console.log(\u0026#34;merge\u0026#34;, mergeSort(arr, 0, arr.length - 1)); 分析 #  "},{"id":14,"href":"/posts/dac/","title":"分治","section":"notes","content":"定义 #  分治：将 大问题 拆为 不相交 的 规模更小 的 子问题 ， 根据子问题的解求出原始问题的解\n分：大问题拆为小问题\n治：解决小问题\n合：由小问题的解合为大问题的解\nSubstitution method #  Recursion-tree method #  递归树方法\nMaster method #  "},{"id":15,"href":"/posts/dp/","title":"动态规划","section":"notes","content":"Dynamic Programming #  动态规划: 由子问题的解推出最终问题的解，子问题重叠，即子问题共享子子问题\n避免重复计算子问题\nElements #  动态规划的基本元素\nOptimal Substructure #  最优子结构，通过子问题的最优解，求出最终的最优解\nOverlapping Subproblem #  重叠子问题\n"},{"id":16,"href":"/posts/rod-cutting/","title":"切钢条问题","section":"notes","content":"草稿，待完善\nRod-Cutting #  切钢条问题\n钢条长度 i 和售价 P(i) 的对照表\n   Length i 1 2 3 4 5 6 7 8 9 10     Price P(i) 1 5 8 9 10 17 17 20 24 30   cut ways 1 2 4 8          求给定长度 n 的钢条的最大销售额 R(n) ?\n解： 设 长度为n 的钢条的最大销售额为 R(n)\nR(n) = Max {P(n), R(1) + R(n -1), R(2) + R(n - 2)}\n"},{"id":17,"href":"/posts/loop-invariant/","title":"循环不变式","section":"notes","content":"Loop Invariant #  循环不变式： 循环的每次迭代中，始终为 true 的断言\n\\( (P \\land condition) \\{ S \\} P \\)，即 \\(P\\) 为循环不变式\n证明循环语句正确的步骤 #   猜测 \\(P\\) 为循环不变式 证明 \\(P\\) 为循环不变式 证明程序会终止 证明程序终止时 \\(P \\land \\neg condition \\) 为 \\( T \\)  "},{"id":18,"href":"/posts/complexity/","title":"算法复杂度","section":"notes","content":"Time complexity #  时间复杂度\n算法执行所需的操作数，而不是实际的运行时间\n当输入 n 足够大时，低阶项可以被舍弃\nRAM #  Random Access Machine\n 单处理器 指令按序处理，无并发操作 仅包含常用指令，每个指令的执行占用常量操作时间  Average case #  对 size n 的 平均 输入，算法执行所需的操作数，（平均运行时间）\n通常要用到概率分析的方法\nWorst case #  对 size n 的任意输入，算法执行所需的最大操作数，即运行时间的 上界 (上限)\n使算法执行时间最长的输入，例如对插入排序而言，待排序数组是已经反向排序好的\n最常用\nBest case #  使算法执行时间最短的输入，例如对插入排序而言，待排序数组是已经正向排序好的\n\\( \\Theta \\) notation #  \\( \\Theta(g(n)) = \\{f(n): \\exists c_1, c_{2}, n_{0} \\in \\mathbb{R^{+}} , \\forall n_{0} \\leq n, 0 \\leq c_{1}g(n) \\leq f(n) \\leq c_{2}g(n) \\} \\)\n\\(f(n) = \\Theta(g(n))\\)，即 \\(f(n) \\in \\Theta(g(n))\\)，\\(f(n)\\) 为集合 \\(O(g(n))\\) 中的一员\n\\(\\Theta(g(n)) \\subseteq O(g(n)) \\)\n算法 最坏运行时间 的紧界，不能表示对 任意 输入算法运行时间的紧界\n定理：对函数\\(f(n), g(n)\\)而言，当且仅当 \\(f(n)=O(g(n))\\), \\(f(n)=\\Omega(g(n))\\) 时， \\(f(n) = \\Theta(g(n))\\)\n\\(O\\) notation #  \\( O(g(n)) = \\{f(n): 存在常量 c, n_{0} \\in \\mathbb{R^{+}} , \\forall n_{0} \\leq n, 0 \\leq f(n) \\leq cg(n) \\} \\)\n大 \\(O\\) 表示法，表示对大小为 n 的 任意 输入，算法运行时间的 上界\n\\(\\Omega\\) notation #  大 \\( \\Omega \\) 表示法，表示对大小为 n 的 任意 输入，算法运行时间的 下界\n对 size n 的任意输入，*最好运行时间* 的下界；例如对插入排序而言，元素都是已经排序好的情况下\n\\(o\\) notation #  小 \\(o\\) 表示法，跟 大\\(O\\)的区别为，对任意常量 c\n不紧的上界，要低一个阶\n例如：\\(2n = o(n^{2}) \\)，但 \\(2n^{2} \\neq o(n^{2}) \\)\n\\(\\omega\\) notation #  小 \\(\\omega\\) 表示法\n不紧的下界，要高一个阶\n图例 #   \\(n_{0} 为最小可能值\\)\n 常用函数增长曲线\nSpace complexity #  空间: 内存\n空间复杂度：算法输入所占据的内存 + 辅助内存\nSpace Complexity = Auxiliary space + Space used by input values\nRecursive call stack，递归调用栈也算空间占用\n空间复杂度跟实现算法所使用的数据结构有关\nAuxiliary space #  辅助空间： 算法执行需要的额外空间\nIn place #  "},{"id":19,"href":"/posts/regexp/","title":"js 正则表达式","section":"notes","content":"Character Class #  字符类\n   字符 含义     \\d 数字   \\D 非数字   \\s 空格，换行符，制表符   \\S 非 \\s   \\w 拉丁字母，数字，下划线 _   \\W 非 \\w   . 除 \\n 外的任意字符; 如果有 s flag，则为任意字符    Quantifiers #  量词，用于针对其前面的字符的数量的修饰\n   字符 含义     {n} n个   + 1或多，[1, +\\(\\infty\\) )   * 0或多，[0, +\\(\\infty\\) )   ? 0或1，{0, 1}    "},{"id":20,"href":"/posts/prototype/","title":"js 原型","section":"notes","content":"草稿，待完善\n[ [Prototype] ] #  隐藏属性，决定继承关系\n__proto__ #  历史遗留的 getter/setter ，不建议使用\n建议使用这俩： Object.getPrototypeOf/Object.setPrototypeOf\n"},{"id":21,"href":"/posts/async/","title":"异步","section":"notes","content":"草稿，待完善\n同步 #  run to completion\n异步 #  Reactor Pattern #  异步的底层原理 #  操作系统的 api\nCallback #  Generator #  Promise #  Async/Await #  Observable #  IO #  网络请求，文件读写\n同步io：应用初始化的时候读配置文件用，否则不建议使用同步 io，阻塞 eventloop，影响性能\nqueueMicrotask #  ecma-262 标准方法，用于注册微任务\nprocess.nextTick #  任务队列，被 node 管理，仅在 node 环境支持\n优先级高于微任务\n并发 #  并行 #  Worker Threads #  setImmediate #  非标准方法，不推荐使用，仅在 node 环境支持\n宏任务，在 poll phase 阶段后执行\nEvent Loop #  等待任务，执行任务，继续等待任务（等待期基本不消耗 cpu 资源）\nnode 环境跟 browser 环境的 event loop 表现不一致\nBrowser event loop #  使用 libevent 来实现，单队列\n Node event loop #  多阶段，每阶段一个队列使用 libuv 来实现分不同的阶段 phase，每个阶段可以理解成一个队列 Node 11.0.0 修复了微任务的 bug 四个 phase (队列） expired timer callbacks i/o events immediate queues close handler 中间队列 process.nextTick/promise 微任务\n Event Loop 最佳实践 #  事件的区别 #  浏览器事件：用户交互，脚本加载等，服务端事件：文件 i/o，网络 i/o，\n   环境 browser node     \u0026mdash; \u0026mdash; \u0026mdash;   实现库 libevent libuv    libuv #  Network I/O is not performed on the libuv thread pool\nFile I/O在 libuv thread pool 里执行\ndns.lookup() 在 libuv 线程池里执行\n libuv 线程池 #  微任务 #  v8 术语，由引擎管理的任务队列\n.then/.catch/.finally queueMicrotask 注册的均为微任务\n当前宏任务执行完后，引擎会执行微任务，优先级高于宏任务\n宏任务 #  v8 术语\n例如：脚本加载事件，页面交互事件\n执行宏任务时，浏览器不会渲染\nNode架构 #   参考 #    https://stackoverflow.com/questions/55467033/difference-between-process-nexttick-and-queuemicrotask  https://blog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810  https://gist.github.com/deepal?page=1  "},{"id":22,"href":"/posts/symbol/","title":"常用数学符号","section":"notes","content":"SETS #     符号 含义     \\(\\mathbb{N}\\) 自然数   \\(\\mathbb{Z}\\) 整数   \\(\\mathbb{Z^+}\\) 正整数   \\(\\mathbb{Q}\\) 有理数   \\(\\mathbb{R}\\) 实数    "},{"id":23,"href":"/posts/induction/","title":"归纳和递归","section":"notes","content":"数学归纳和递归 #  数学归纳 #  证明：当 \\( n \\in \\mathbb{Z^+} \\) 时，\\(P(n)\\) 成立。\n基础条件： 证明 \\(P(1)\\) 成立\n归纳条件： 证明对 \\(\\forall k \\in \\mathbb{Z^+} \\)， \\(P(k) \\rightarrow P(k+1) \\) 成立\n即可证原命题成立\n推理公式： \\( (P(1) \\land \\forall k (P(k) \\rightarrow P(k+1))) \\rightarrow \\forall n P(n) \\)，\\(n,k \\in \\mathbb{Z^+}\\)\n递归 #  "},{"id":24,"href":"/posts/fiber/","title":"React Fiber","section":"notes","content":"fiber 基本工作原理 #  每一 react element 构造一个 fiber 节点，每个 fiber 节点是一个工作单元，一系列 fiber 节点构成一个 fiber 特殊的链表。该数据结构的优点是便于找到下次的工作单元\n 针对每个 fiber 节点要做三件事：\n 将元素添加到 dom 上 创建该元素 children 的 fiber 节点 选择下次的工作单元  工作单元执行顺序： 执行完所有的 children，如果没有 children，则执行其兄弟节点，如果没有 children 也没有兄弟节点执行其 uncle，没有 uncle 则到 root\nfiberNode 的简单结构:\nconst newFiber = {  type: element.type, // 当前fiber的类型  props: element.props, // 当前fiber的props  parent: fiber, // 指向父级fiber节点  dom: null, // 该fiber节点对应的dom对象  alternate: null, // 指向上次commit的fiberNode  effectTag: \u0026#39;PLACEMENT\u0026#39;, // commit阶段用到  hooks: [], }; 每个 fiber 节点的工作完成之后，commit 整个 fiber tree 到 dom 上\n函数式组件没有对应的 dom 节点, 需要调用函数拿到其 children\ndiff 算法 #   如果旧 fiber 跟新元素类型一致，保留 dom 节点，仅更新 props 如果旧 fiber 跟新元素类型不一致，需要创建新的节点，替换掉旧的节点 在这里用 key 去标识某个 children 是否在元素数组里更换了位置  "},{"id":25,"href":"/posts/tree/","title":"树","section":"notes","content":"定义 #  树： 连接的 无向 *无环图 *\nPath #  路径： 节点和边的序列\n路径长度； 路径里边的数量\nDepth #  节点深度： 从根节点到当前节点的 路径 长度\nLevel #  节点层级：节点 depth + 1， （很少用）\n树的层级：节点层级的最大值\nHeight #  节点高度： 从当前节点到 叶节点 的 最长 路径 长度\n树的高度： 根节点的高度\nWidth #  树在深度 d 的宽度： 树在深度 d 的节点数量\n树的宽度： 所有深度的最大宽\nBinary Tree #  二叉树\nBalanced #  平衡树的高度为 \\(O(log n)\\)\nHeight-Balanced #  高度平衡，对任意节点而言，其子树的高度差 最多 为 1，空子树的高度为 -1\nWeight-Balanced #  宽度平衡，对任意节点，其子树的 内部节点 （不包括叶节点），数量差 最多 为 1，宽度平衡的树也是高度平衡的\nComplete #  完整二叉树，除最后一层外，每一层都是完整填满的，最后一层的节点尽可能 靠左\nFull #  满二叉树，每一个节点都有 0 或 2 个子节点\nPerfect #  完美二叉树，所有叶节点都在同一层的 满二叉树 或 每一层都填满的 完整二叉树\nBST #  Binary Search Tree，二叉搜索树\n新增或删除节点时，需 保持平衡 ，比较低效\n特点：\n 每个节点都有值 每个节点的左子树的所有节点值都比当前节点的值要小 每个节点的右子树的所有节点值都比当前节点的值要大  BST 不能包含重复值\nAVL #  2-3 #  B-Tree #  Red-Black #  In order #  中序遍历：\n 左子树 (in order) 根节点 右子树 (in order)  Pre order #  前序遍历：\n 根节点 左子树 (pre order) 右子树 (pre order)  Post order #  后序遍历：\n 左子树 (post order) 右子树 (post order) 根节点  "},{"id":26,"href":"/posts/proof/","title":"如何证明","section":"notes","content":"Proof method #  证明方法\nTheorem #  定理： 可证明为真的语句 （事实，真相）\nAxioms #  公理： 假定为 true 的语句 (statements)\nlemma #  引理，辅助定理\nProof #  证明 p true， q 为 true\nDirect proof #  直接证明\nif p true, p -\u0026gt; q true, q true\nContraposition #  ~q -\u0026gt; ~p\nContradiction #  矛盾法\n"},{"id":27,"href":"/posts/logic/","title":"命题逻辑","section":"notes","content":"Proposition logic #  Proposition #  命题： 描述性语句，要么真，要么假\nConditional Statements #  if p, then q, i.e. p -\u0026gt; q\n"},{"id":28,"href":"/posts/network/","title":"计算机网络","section":"notes","content":"计算机网络基础 #  三次握手 #   client 发送 syn（Synchronize Sequence Number）到 server，表示想要建立 tcp 连接 Server 发送(syn+ ack) client 发送 ack 给 server，连接建立  四次挥手 #   client 发送 FIN server 接收到 FIN，发送 ack server 发送 FIN client 发送 ack  网络分层 #  TCP/IP 模型 #   应用层 传输层 网络层 链路层  OSI 模型 #   应用层 展示层 会话层 传输层 网络层 链接层 物理层  "},{"id":29,"href":"/posts/cache/","title":"缓存","section":"notes","content":"缓存 #  为什么需要缓存 #   减少不必要的网络请求，提升页面访问速度 减少服务器负载 节省网络开销(流量)  缓存工作机制 #  通过 http 请求头及 http 响应头来控制\n缓存相关 http header #  Expires #  Fri, 30 Oct 1998 14:19:41 GMT，优先级较低\n服务端返回 ，GMT 时间戳。告诉浏览器在指定的时间戳之后重新获取新的资源。限制：服务器跟浏览器的时间必须保持同步\nCache-Control #  Max-age = 3153000 单位秒\n   属性 含义     private 仅允许浏览器缓存   public 可被任意节点缓存   no-cache 每次都需要验证缓存的有效性   no-store 不允许被缓存    服务端返回\nLast-Modified #  Mon, 03 Jan 2011 17:45:57 GMT\n服务端返回 ，用来重新校验缓存是否有效, GMT 时间戳\nETag #  e.g. ETag: x234dff\n服务端返回 ，当浏览器端某个缓存过期，浏览器会发送一段 token（通常是文件的 hash 值）来请求服务器判断该文件是否过期。如果 ETag 不变，则继续使用缓存\nIf-None-Match #  If-None-Match: x234dff\n浏览器端发送 ，检查此值是否跟 server 端的 ETag 值匹配\nIf-Modified-Since #  Mon, 03 Jan 2011 17:45:57 GMT\n浏览器端发送\n"},{"id":30,"href":"/posts/146-lru/","title":"lc-146","section":"notes","content":"Least recently used cache #  最近 最少 使用的缓存\n解法： 双链表 + hash 表\n /** * Least Recently Used cache * Get: O(1), hash 表 * Put: O(1)，需要维持顺序，最近最少使用的节点要删掉 * * 双向链表 */ class LRUCache {  constructor(capacity) {  // 当前元素数量  // 容量上限  this.capacity = capacity;  /** @type {{[index: number]: LinkedListNode}} */  this.cache = {};  // 当前容量  this.size = 0;   // 伪头结点  this.head = new LinkedListNode(0, 0);  // 伪尾节点  this.tail = new LinkedListNode(0, 0);   // 调整指针指向  this.head.next = this.tail;  this.tail.prev = this.head;  }   /** * @param {number} key */  keyExits(key) {  return this.cache[key] !== undefined;  }   /** * @param {number} key */  get(key) {  if (!this.keyExits(key)) {  return -1;  }   const node = this.cache[key];   this.moveToHead(node);   return node.val;  }   /** * @param {number} key * @param {number} value */  put(key, value) {  // key 存在，更新值  if (this.keyExits(key)) {  const node = this.cache[key];  // 更新值  node.val = value;  // 调整位置，移动到头节点  this.moveToHead(node);  } else {  const node = new LinkedListNode(key, value);   if (this.size === this.capacity) {  // 如果 cache 满了, 移除尾节点  const node = this.removeTail();  delete this.cache[node.key];  this.size--;  }   this.addToHead(node);   this.cache[key] = node;   this.size++;  }  }   /** * 移除尾节点 */  removeTail() {  /** @type {LinkedListNode} */  const node = this.tail.prev;  this.removeNode(node);  // 返回当前真实尾节点的引用  return node;  }   /** * 移动当前节点到头结点 * @param {LinkedListNode} node */  moveToHead(node) {  this.removeNode(node);  this.addToHead(node);  }   /** * 调整节点的指针指向，使其从双链表中删除 * @param {LinkedListNode} node */  removeNode(node) {  node.prev.next = node.next;  node.next.prev = node.prev;  }   /** * 将节点添加到头结点 * @param {LinkedListNode} node */  addToHead(node) {  // 先调整当前节点的指针  node.prev = this.head;  node.next = this.head.next;   this.head.next.prev = node;  this.head.next = node;  } }  class LinkedListNode {  /** * @param { number } key * @param { number } val **/  constructor(key, val) {  this.key = key;  this.val = val;  this.next = null;  this.prev = null;  } } "},{"id":31,"href":"/posts/lc-77/","title":"leetcode-77","section":"notes","content":"组合 #  给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n你可以按 任何顺序 返回答案。\n1 \u0026lt;= n \u0026lt;= 20\n1 \u0026lt;= k \u0026lt;= n\n题解 #   /** * n 选 k 共有多少个组合情况 * @param {number} n * @param {number} k */ const combine = (n, k) =\u0026gt; {  const ans = [];   /** * @param {number} k 子集的元素数 * @param {number} start 从第几个开始选 * @param {number} list 子集数组 */  const getCombine = (k, start, list) =\u0026gt; {  if (k === 0) {  // 选满了  ans.push(list.slice());  return;  }   for (let i = start; i \u0026lt;= n; i++) {  list.push(i);  getCombine(k - 1, i + 1, list);  list.pop(list[list.length -1])  }   };   getCombine(k, 1, []);   return ans;  }; "},{"id":32,"href":"/posts/software-eng/","title":"软件工程基本原则","section":"notes","content":"SOLID 原则 #  S #  Single Responsibility Principle， 单一职责原则\nO #  Open-Closed Principle，对拓展开放，对修改关闭\nL #  Liskov Substitution，里氏替换原则\nI #  Interface Segregation，接口隔离\nD #  Dependency Inversion Principle，依赖倒置原则\n依赖抽象的接口，而不是具体的实现\nDRY 原则 #  "},{"id":33,"href":"/posts/webpack/","title":"Webpack 原理","section":"notes","content":"工作过程 #   根据入口文件构建依赖图 处理依赖图里的所有资源 生成 js bundle，清单文件  代码分割 #  基于入口的代码分割\n"},{"id":34,"href":"/posts/hash-table/","title":"哈希表","section":"notes","content":"Collision #  冲突： H(k1) = H(k2)\n冲突解决方案 #  Chaining #  Open Addressing #  "},{"id":35,"href":"/posts/graph/","title":"图","section":"notes","content":"定义 #  G = (V, E)， V 为非空顶点集，E 为边的集合\nDirected Graph #  有向图\n边 （u, v), u -\u0026gt; v ， v 跟 u 相邻\n没有自循环的有向图是 简单有向图\nUndirected Graph #  无向图\n无向图不允许自循环\nDegree #  度\nPath #  \u0026lt;v0, v1, \u0026hellip; , vk\u0026gt; v0 -\u0026gt; vk 的顶点的一个序列\n长度： 路径中边的数量\nSimple Path #  路径中所有的顶点都是不同的\nCycle #  Edge #  (u, v), 有向图中 (u, v) , (v, u) 是不一致的\nVertex #  Connected #  每一个顶点都能从其他顶点触达到 reachable\n"},{"id":36,"href":"/posts/linked-list/","title":"链表","section":"notes","content":"Singly linked list #  单链表\n时间复杂度 #     Access Search Insertion Deletion     O(n) O(n) O(1) O(n)    注： 插入操作仅为在给定节点 Node 的指针 P 的前提下，在其后面插入一个节点，此时复杂度为 O(1)，若在 P 前面插入一个节点，则复杂度为 O(n), 因为需要遍历\nDoubly linked list #  双链表\n优点： #   可以双向遍历 删除操作更高效(O(1))，在已知给定节点的指针的前提下 插入操作 (O(1))  缺点： #   额外的空间开销，用来存指针 所有操作需要维持两个指针的指向  时间复杂度 #     Access Search Insertion Deletion     O(n) O(n) O(1) O(n) / O(1)    注：如果需要遍历节点，则删除的时间复杂度为 O(n)\n"},{"id":37,"href":"/posts/algo-correctness/","title":"算法正确性","section":"notes","content":"算法正确性证明 #  算法正确：对每一个正确输入，都能得到正确的解\n证明步骤 #   证明程序终止时，能获得正确的解，(部分正确） 证明程序始终会终止  初始断言： 程序输入值具有的属性；结果断言： 程序输出值具有的属性\nHoare triple: p{S}q\nif p true and S terminates, q true, then S is partially correct\n"},{"id":38,"href":"/posts/events-after-input-a-url/","title":"在浏览器地址栏输入 url 会发生什么","section":"notes","content":"浏览器通过 DNS 查询域名对应的 ip 地址 #    检查浏览器 cache\n  检查操作系统 cache\n  检查路由 cache\n  检查 isp cache\n  如果前面四步都没找到，ISP 的 DNS 服务器会向其他 DNS 服务器请求该域名对应的 ip 地址\n  浏览器跟该 ip 地址的 server 建立 tcp 连接 #  3 次握手\n浏览器向该 ip 地址的 server 发起 http 请求 #  server 处理请求并返回 http 响应 #  1**，information\n2**，ok\n3**, 重定向\n4**，客户端错误\n5**，服务器错误\n浏览器开始渲染 html #  构建 dom 树 #  js 的加载会阻塞 dom 树的构建, css, images 不会。css 会阻塞页面渲染\n   事件 含义     window.onload 所有静态资源加载完毕   DOMContentLoaded dom 构建完毕，cssom 构建完毕    构建 cssom #  构建 render 树 #  dom + cssom = render tree，移除不显示到屏幕上的节点\n布局 (layout) #  计算 render tree 里每一个节点的位置，尺寸等\n绘制 (paint) #  浏览器请求 html 里依赖的资源（images，css，javascript） #      执行顺序 是否阻塞页面渲染 适用场景     async 谁先加载完谁先执行 否 独立第三方脚本，广告等。执行顺序无关联的脚本   defer 谁的位置靠前谁先执行 否 依赖 dom 的脚本，依赖执行顺序的脚本    页面加载完成后，如果有其他的异步请求（xhr，fetch），浏览器会再次发起请求 #  "},{"id":39,"href":"/posts/number-theory/","title":"数论","section":"notes","content":"整除 #  \\(a \\ | \\ b\\)： 即如果 \\(a, b, c \\in \\mathbb{Z}, a \\neq 0, \\exists c(ac = b)\\) ，则说明 a 能整除 b，a 为 b 的因子或除数;\n反之，若 \\(\\nexists c\\)，则 \\( a \\nmid b\\)，即 a 不能整除 b\nDivision Algorithm #  假设 \\(a \\in \\mathbb{Z}, d \\in \\mathbb{Z^+}\\) ， 存在唯一的 \\( q, r \\in \\mathbb{Z} , 0 \\leq r \u0026lt; d \\)， 使 \\( a = dq + r\\)\nd 为除数，a 为被除数，q 为商，r 为余数\nq = a div d ， r = a mod d\n模运算 #  定理：如果 \\(a, b \\in \\mathbb{Z}, m \\in \\mathbb{Z^+}，m \\mid (a - b) \\)，则 a, b 对 m 同余，简写为 \\( a \\equiv b \\pmod m \\)\n即 a mod m = b mod m ，m 为模数\n定理：a，b 同余时，\\( \\exists k \\in \\mathbb{Z}， a = b + km \\)\nArithmetic Modulo #  算术模运算\n\\(a \\cdot _m b = (a \\cdot b)\\mod m\\)\n\\(a + _m b = (a + b)\\mod m\\)\nFast Modulo Exponentiation #  质数 #  质数又称之为素数\n只能被 1 和 其自身 整除的 大于 1 的整数，反之称为 合数\n定理： 任何一个大于 1 的整数，可以唯一的表示为一个质数或多个（ \\([2, +\\infty)\\) ）质数的积，质因数按增序书写\nRelatively Prime #  互质：整数 a 和 b 的最大公约数为 1， 则 a 与 b 互质，即 \\(gcd(a,b) = 1\\)\nPairwise Relatively Prime #  成对互质，两两互质\nGreatest Common Divisor #  最大公因数：能 整除 两个整数的 最大 整数，表示为 \\(gcd(a,b)\\)\nLeast Common Multiple #  最小公倍数\n\\(a, b \\in \\mathbb{Z^+}, a \\cdot b=gcd(a,b) \\cdot lcm(a,b) \\)\nLinear Congruence #  线性同余，\\(a \\cdot x \\equiv b \\pmod m\\)，x 为变量\n模的逆：\\(\\exists \\bar a \\in \\mathbb{Z} , \\bar a \\cdot a \\equiv 1 \\pmod m \\)，\\( \\bar a \\) 为 \\( a \\mod m\\) 的逆，用来求解线性同余里的 x\n应用：给计算机文件分配内存地址，伪随机数的生成，位校验\n"},{"id":40,"href":"/posts/cryptography/","title":"Cryptography","section":"notes","content":"Cryptography #  密码学\n数据私密性，数据的完整性，端的身份认证\nEnd-Point authentication #  端的身份认证，网络中一个实体向另一个实体证明他的身份，服务端的身份认证，客户端的身份认证\nThread Model #  Playback attack #  "},{"id":41,"href":"/posts/https/","title":"HTTPS","section":"notes","content":"SSL/TSL #  SSL #  Secure Sockets Layer\nTLS #  Transport Layer Security\nSSL 3 的微小修订版，被 IETF 标准化\nHTTPS #  "},{"id":42,"href":"/posts/map/","title":"Map","section":"notes","content":"Map #   key 的顺序不会自动排序，始终保留其插入时的相对顺序 key 可以是任意数据类型  "},{"id":43,"href":"/posts/math/","title":"Math","section":"notes","content":"中文标题 #  中文内容 #   我是内容1 我是内容2  LaTeX formatted equation: \\( E = -J \\sum_{i=1}^N s_i s_{i+1} \\)\nIf \\(a^2=b\\) and \\( b=2 \\), then the solution must be either \\[ a=+\\sqrt{2} \\] or \\[ a=-\\sqrt{2} \\]\ntest math\n"},{"id":44,"href":"/posts/org-mode/","title":"Org Mode","section":"notes","content":"测试 org mode 的功能 #  Table #     foo bar     图文咨询 标注   我是前端，图文自诩你的贵 华为的弹   东西哈哈哈，仪表板，你说了 窗卡顿，   ，非医生 oh ,    bullshit   入组触发，选择器，前端 发布yes    Math #  If \\(a^2=b\\) and \\( b=2 \\), then the solution must be either \\[ a=+\\sqrt{2} \\] or \\[ a=-\\sqrt{2} \\].\n\\begin{equation} x=\\sqrt{b} \\end{equation}\n"},{"id":45,"href":"/posts/security/","title":"Security","section":"notes","content":"Security #  Thread Model #  Playback attack #  Confidentiality #  数据的机密性\nIntegrity #  完整性\nData integrity #  Originality #  timeliness #  Authentication #  端的身份认证\n网络中一个实体向另一个实体证明他的身份，服务端的身份认证，客户端的身份认证\n"},{"id":46,"href":"/posts/task/","title":"Task","section":"notes","content":"任务队列 #  requestIdleCallback 和 requestAnimationFrame 的区别\nric #  在每一帧的空闲期执行，可能不执行\nraf #   通过事件监听器注册的回调将会在同一帧中执行 通过 raf 注册的回调将在下一帧中执行  "},{"id":47,"href":"/posts/rsa/","title":"RSA 加密算法","section":"notes","content":"图解 #   "},{"id":48,"href":"/posts/network-security/","title":"网络安全","section":"notes","content":"什么是安全通信 #  假定 Alice, Bob 为两个通讯实体，Trudy 为中间攻击人，如何保证 Alice 和 Bob 能进行安全通信 ？\nConfidentiality #  数据的机密性，即只有通信双方可以知道通信内容\nIntegrity #  消息完整性\nData Integrity #  Alice 发的消息没有被篡改\nOriginality #  Bob 收到的消息确实是 Alice 发的\nTimeliness #  Authentication #  通信侧的身份认证\n网络中一个实体向另一个实体证明他的身份，服务端的身份认证，客户端的身份认证，Alice 证明她就是 Alice\nThread Model #  攻击者如何破坏通信安全\n窃听 #   嗅探，记录信道通信报文 篡改，插入，删除通信报文  Playback Attack #  攻击者把以前发过的消息又发了一遍\nSuppress-replay Attack #  抑制-重放攻击\nCryptography #  cryptography，密码学，网络安全的基石\n加密算法是已知的，公开的，秘钥是私密的\nCaesar Cipher #  凯撒加密法\nenc: \\(f(p) = (p + k) \\mod 26\\)\ndec: \\(f(p) = (p - k) \\mod 26\\)\n破解： 概率学分析\nSymmetric-Key Cipher #  对称秘钥加密（一个秘钥），比非对称秘钥更快\n难点：如何安全的交换和保存秘钥\nStream Cipher #  流加密\nBlock Cipher #  块加密\n DES: Data Encryption Standard AES: Advanced Encryption Standard CBC: Cipher Block Chaining  破解 #  需要知道秘钥和加密方法\nPublic Key Cipher #  非对称秘钥加密，公钥加密\n特点：\n 两个秘钥 公钥加密，私钥解密 私钥 私有 ，公钥公开 速度较慢  RSA #  破解 #  需要知道私钥和加密算法\n秘钥分发 #  Session Key #  symmetric key， 只有通讯双方知道的单一 key，必须保持私密\n仅在单次会话期有效\nlongerlived Predistributed Keys. #  长生命周期的预分配秘钥\n公钥分发，校验 #  如何确认公钥属于 Alice ?\nDiffie-Hellman Key Agreement #  DH 秘钥协商\nKey Distribution Center #  秘钥分发中心\nPublic Key Infrastructure #  公钥体系，维护公钥和实体的关系；\nPKI 体系运作的前提为 CA 机构可信\n信任链\n原理：\n 基于信任的传递 浏览器预装了 CA 机构的证书  Public Key Certificate #  公钥证书，简称证书，其中一个主要的证书标准为 X.509\n证书内容：\n 待认证的实体的身份（email 或 域名） 待认证的实体的公钥 签名者的身份 数字签名 数字签名算法的标识 证书过期时间（可选）  Certificate Authority #  证书颁发机构，简称 CA\n信任模型 #  基于 CA #  绝对可信或绝对不可信，依赖第三方\n基于 web of trust (信任网)，例如 PGP #  在这个模型里，信任是一定程度的信任，让用户自己去决定信任与否\n证书撤销 #  当私钥泄露时，证书应该被撤销\nca 机构维护 certificate revocation list\nMAC #  message authentication code，消息校验码\nm: 消息，s: 共享秘钥，Mac: MAC 算法\nMAC = Mac(m + s)，固定长度的认证标签，与输入的长度无关\n只有知道 key 的通信双方才能计算出一致的 MAC，避免消息被篡改\nMAC 的属性 #   使用对称性秘钥 可对计算任意长度的消息进行计算 固定长度的输出值，与输入的长度无关 可证明消息的完整性 可证明消息的可靠性 无法证明消息的不可否认性（Alice 和 Bob 都能计算出一致的 MAC 值）  HMAC #  hash-based message authentication code\nMAC 的一种实现方式，基于 Hash 算法\nDigital Signature #  私钥签名，公钥验签\nSSL/TLS #  SSL #  Secure Sockets Layer，安全套接字层，最早是 Netscape 研发\nTLS #  Transport Layer Security，传输层安全\nSSL 3 的微小修订版，被 IETF 标准化\nHTTPS #  HTTP + SSL/TLS\n握手协议 #  握手阶段，协商以下三个部分：\n 数据完整性 Hash 算法（MD5，SHA-1，etc.），用于 HMAC 对称秘钥算法（DES, AES） session key 交换方法  Master Secret #  主密钥，用于生成以下四个秘钥\n Eb：session 加密秘钥，用于加密从 Bob 发给 Alice 的消息 Mb：session MAC 秘钥，校验 Bob 发给 Alice 的消息的完整性 Ea：与上反之 Ma：与上反之  Encrypted Master Secret #  "}]